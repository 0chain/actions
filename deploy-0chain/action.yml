name: "Deploy 0Chain Network"
description: "Deploy 0Chain Network to k8s cluster using helm"
inputs:
  kube_config:
    description: 'cluster details'
    required: true
  miner_image:
    description: 'miner DOCKER IMAGE to deploy'
    default: 'staging'
    required: false
  sharder_image:
    description: 'sharder DOCKER IMAGE to deploy'
    default: 'staging'
    required: false
  blobber_image:
    description: 'blobber DOCKER IMAGE to deploy'
    default: 'staging'
    required: false
  validator_image:
    description: 'validator DOCKER IMAGE to deploy'
    default: 'staging'
    required: false
  authorizer_image:
    description: 'authorizer DOCKER IMAGE to deploy'
    default: 'staging'
    required: false
  zbox_image:
    description: '0box DOCKER IMAGE to deploy'
    default: 'staging'
    required: false
  zblock_image:
    description: '0block DOCKER IMAGE to deploy'
    default: 'staging'
    required: false
  zdns_image:
    description: '0dns DOCKER IMAGE to deploy'
    default: 'staging'
    required: false
  explorer_image:
    description: 'Explorer DOCKER IMAGE to deploy'
    default: 'latest'
    required: false
  zproxy_image:
    description: '0Proxy DOCKER IMAGE to deploy'
    default: 'staging'
    required: false
  zsearch_image:
    description: '0Search DOCKER IMAGE to deploy'
    default: 'staging'
    required: false
  blobber_stake_image:
    description: 'Blobber stake DOCKER IMAGE to deploy'
    default: 'latest'
    required: false
  teardown_condition:
    description: 'Variable on which to teardown network'
    default: 'ALWAYS_TEARDOWN'
    required: false
  miner_fee:
    description: 'Miner fee per transaction'
    default: '0'
    required: false


runs:
  using: "composite"
  steps:
    - name: "Setup Config"
      shell: 'script --return --quiet --command "bash {0}"'
      run: |
        echo "NETWORK_URL=$(echo dev-${RUNNER_NAME:(-1)}.devnet-0chain.net)" >> $GITHUB_ENV
        echo "MINER_TAG=$(echo '${{inputs.miner_image}}')" >> $GITHUB_ENV
        echo "SHARDER_TAG=$(echo '${{inputs.sharder_image}}')" >> $GITHUB_ENV
        echo "BLOBBER_TAG=$(echo '${{inputs.blobber_image}}')" >> $GITHUB_ENV
        echo "VALIDATOR_TAG=$(echo '${{inputs.validator_image}}')" >> $GITHUB_ENV
        echo "AUTHORIZER_TAG=$(echo '${{inputs.authorizer_image}}')" >> $GITHUB_ENV
        echo "ZBOX_TAG=$(echo '${{inputs.zbox_image}}')" >> $GITHUB_ENV
        echo "ZDNS_TAG=$(echo '${{inputs.zdns_image}}')" >> $GITHUB_ENV
        echo "ZBLOCK_TAG=$(echo '${{inputs.zblock_image}}')" >> $GITHUB_ENV
        echo "EXPLORER_TAG=$(echo '${{inputs.explorer_image}}')" >> $GITHUB_ENV
        echo "BLOBBER_STAKE_TAG=$(echo '${{inputs.blobber_stake_image}}')" >> $GITHUB_ENV
        echo "ZPROXY_TAG=$(echo '${{inputs.zproxy_image}}')" >> $GITHUB_ENV
        echo "ZSEARCH_TAG=$(echo '${{inputs.zsearch_image}}')" >> $GITHUB_ENV
        ALWAYS_TEARDOWN=true
        echo "TEARDOWN_CONDITION=${{inputs.teardown_condition}}" >> $GITHUB_ENV
        echo "MINER_FEE=${{inputs.miner_fee}}" >> $GITHUB_ENV

        echo "RUNNER_NUMBER=${RUNNER_NAME:(-1)}" >> $GITHUB_ENV
        echo "NAMESPACE=dev-${RUNNER_NAME:(-1)}" >> $GITHUB_ENV

    - name: "VIEW DEPLOY CONFIGURATION"
      shell: 'script --return --quiet --command "bash {0}"'
      run: |
        echo
        echo "=================================================="
        echo "DEPLOYING 0CHAIN WITH THE FOLLOWING CONFIGURATION:"
        echo "=================================================="
        echo
        echo "0Chain network URL:      [${{ env.NETWORK_URL }}]"
        echo "Miner docker image:      [${{ env.MINER_TAG }}]"
        echo "Sharder docker image:    [${{ env.SHARDER_TAG }}]"
        echo "Blobber docker image:    [${{ env.BLOBBER_TAG }}]"
        echo "Validator docker image:  [${{ env.VALIDATOR_TAG }}]"
        echo "Authorizer docker image: [${{ env.AUTHORIZER_TAG }}]"
        echo "0box docker image:       [${{ env.ZBOX_TAG }}]"
        echo "0dns docker image:       [${{ env.ZDNS_TAG }}]"
        echo "0block docker image:     [${{ env.ZBLOCK_TAG }}]"
        echo "0Proxy docker image:     [${{ env.ZPROXY_TAG }}]"
        echo "0Search docker image:    [${{ env.ZSEARCH_TAG }}]"
        echo "Explorer docker image:   [${{ env.EXPLORER_TAG }}]"
        echo "Stake docker image:      [${{ env.BLOBBER_STAKE_TAG }}]"

    - name: "Install helm"
      uses: azure/setup-helm@v1
      with:
        version: 'v3.2.2'

    - name: "Install kubectl"
      uses: azure/setup-kubectl@v1
      id: install

    - name: "Configure helm & kubectl"
      shell: 'script --return --quiet --command "bash {0}"'
      run: |
        echo
        echo "=================================================="
        echo "CONFIGURING HELM"
        echo "=================================================="
        echo
        cd ..
        helm repo remove 0chain-helm
        helm repo add 0chain-helm http://0chain-helm-chart.s3-website.us-east-2.amazonaws.com/staging/
        helm repo update
        mkdir -p ./kube
        echo "${{ inputs.kube_config }}" | xargs | base64 -d > ./kube/${{ env.NAMESPACE }}-config

    - name: "Remove existing 0Chain network and data"
      shell: 'script --return --quiet --command "bash {0}"'
      run: |
        cd ..
        echo '#!/bin/bash
        echo
        echo "=================================================="
        echo "REMOVING EXISTING 0CHAIN NETWORK"
        echo "=================================================="
        echo

        output=$(helm list -n ${{ env.NAMESPACE }} --kubeconfig "./kube/${{ env.NAMESPACE }}-config" -a | wc -l);
        if [ $output -gt 1 ]; then
            helm list --short -n ${{ env.NAMESPACE }} --kubeconfig "./kube/${{ env.NAMESPACE }}-config" -a | xargs -L1 helm delete -n ${{ env.NAMESPACE }} --kubeconfig "./kube/${{ env.NAMESPACE }}-config"
            sleep 30
        fi
            helm upgrade --install --wait --timeout 120s cleanup -n ${{ env.NAMESPACE }} 0chain-helm/cleanDir --kubeconfig ./kube/${{ env.NAMESPACE }}-config
            kubectl wait --for=condition=complete --timeout 900s job/helm-clean-directory -n ${{ env.NAMESPACE }} --kubeconfig ./kube/${{ env.NAMESPACE }}-config
            kubectl delete all --all -n ${{ env.NAMESPACE }} --kubeconfig ./kube/${{ env.NAMESPACE }}-config
        ' > ./teardown.sh;
        chmod 777 ./teardown.sh;
        ./teardown.sh

    - name: "Override blobber values.yaml"
      shell: 'script --return --quiet --command "bash {0}"'
      run: |
        cd ..
        echo '
        serviceAccount:
          # Specifies whether a service account should be created
          create: true
          # Annotations to add to the service account
          annotations: {}
          # The name of the service account to use.
          # If not set and create is true, a name is generated using the fullname template
          name: ""

        zminer: false #Enable to make the deployment for 0miners also set blockWorker URL in config.
        affinity:
          blobber:
            storageOptimize: false #Enable this to schedule the blobbers preferrablly over to the nodes with labels bound:high-storage.

        blobber:
          blobberCount: 6
          replicaCount: 1

          # namespace: helm
          host: 0chain.net

          minioConfig:
            bucketUrl: s3.amazonaws.com
            accessKeyId: ajkfjasdfsdv
            secretAccessKey: davddcasdc
            bucketName: blobber
            bucketRegion: us-east-2

          config:
            version: "1.0"
            logging:
              level: "debug"
              console: "false" # printing log to console is only supported in development mode
            # for testing
            #  500 MB - 536870912
            #    1 GB - 1073741824
            #    2 GB - 2147483648
            #    3 GB - 3221225472
            #  100 GB - 107374182400
            capacity: "107374182400" # 100 GB bytes total blobber capacity
            readPrice: "0.01"     # token / GB for reading
            writePrice: "0.01"    # token / GB / time_unit for writing
            priceInUsd: "true"
            priceWorkerInHours: "12"
            # the time_unit configured in Storage SC and can be given using
            #
            #     ./zbox sc-config
            #
            # min_lock_demand is value in [0; 1] range; it represents number of tokens the
            # blobber earned even if a user will not read or write something
            # to an allocation; the number of tokens will be calculated by the following
            # formula (regarding the time_unit and allocation duration)
            #
            #     allocation_size * write_price * min_lock_demand
            #
            minLockDemand: "0.1"
            # max_offer_duration restrict long contracts where,
            # in the future, prices can be changed
            maxOfferDuration: "744h" # 31 day
            challengeCompletionTime: "2m" # duration to complete a challenge
            # these timeouts required by blobber to check client pools, perform
            # a task and redeem tokens, it should be big enough
            readLockTimeout: "1m"
            writeLockTimeout: "1m"
            maxFileSize: "10485760" #10MB
            # update_allocations_interval used to refresh known allocation objects from SC
            updateAllocationsInterval: "1m"
            # delegate wallet (must be set)
            delegateWallet: "b7ebf17502288c0ef27edc52423372aab12b595f0aeb55f3960a3bbc6c47a574"
            # min stake allowed, tokens
            minStake: "1.0"
            # max stake allowed, tokens
            maxStake: "100.0"
            # maximum allowed number of stake holders
            numDelegates: "50"
            # service charge of the blobber
            serviceCharge: "0.30"
            # min submit from miners
            minSubmit: "50"
            # min confirmation from sharder
            minConfirmation: "50"
            blockWorker: "http://helm-zdns-01"
            handlers:
              rateLimit: "10" # 10 per second
            serverChain:
              id: "0afc093ffb509f059c55478bc1a60351cef7b4e9c008a53a6cc8241ca8617dfe"
              owner: "edb90b850f2e7e7cbd0a1fa370fdcc5cd378ffbec95363a7bc0e5a98b8ba5759"
              genesisBlock:
                id: "ed79cae70d439c11258236da1dfa6fc550f7cc569768304623e8fbd7d70efae4"
              signatureScheme: "bls0chain"
              transaction:
                minFee: 1000000000
            contentrefCleaner:
              frequency: "30"
              tolerance: "3600"
            openconnectionCleaner:
              frequency: "30"
              tolerance: "3600"
            writemarkerRedeem:
              frequency: "10"
              numWorkers: "5"
            readmarkerRedeem:
              frequency: "10"
              numWorkers: "5"
            challengeResponse:
              frequency: "10"
              numWorkers: "5"
              maxRetries: "20"
            db:
              name: "blobber_meta"
              user: "blobber_user"
              password: "blobber"
              host: "postgres"
              port: "5432"
            geolocation:
              latitude: "0"
              longitude: "0"
            minio:
              # Enable or disable minio backup service
              start: "false"
              # The frequency at which the worker should look for files, Ex: 3600 means it will run every 3600 seconds
              workerFrequency: "1800" # In Seconds
              # Use SSL for connection or not
              useSsl: "false"
            coldStorage:
              # Minimum file size to be considered for moving to cloud
              minFileSize: "1048576" #in bytes
              # Minimum time for which file is not updated or not used
              fileTimeLimitInHours: "1" # 720 #in hours
              # Number of files to be queried and processed at once
              jobQueryLimit: "100"
              # Capacity filled in bytes after which the cloud backup should start work
              startCapacitySize: "10485760" # 536870912 # 500MB
              # Delete local copy once the file is moved to cloud
              deleteLocalCopy: "true"
              # Delete cloud copy if the file is deleted from the blobber by user/other process
              deleteCloudCopy: "true"
            # integration tests related configurations
            integrationTests:
              # address of the server
              address: "host.docker.internal:15210"
              # lock_interval used by nodes to request server to connect to blockchain
              # after start
              lockInterval: "1s"

          image:
            repository: 0chaindev/blobber
            pullPolicy: Always
            tag: staging

          imagePullSecrets: 
            - name: regcred

          nameOverride: ""

          fullnameOverride: ""

          podAnnotations: {}

          podSecurityContext: {}
            # fsGroup: 2000

          securityContext: {}
            # capabilities:
            #   drop:
            #   - ALL
            # readOnlyRootFilesystem: true
            # runAsNonRoot: true
            # runAsUser: 1000

          env:
            DOCKER: "true"
            DB_NAME: blobber_meta
            DB_USER: blobber_user
            DB_PASSWORD: blobber
            DB_PORT: "5432"

          resources:
            requests:
              cpu: "50m"
              memory: "50Mi"
            limits:
              cpu: "100m"
              memory: "100Mi"

          service:
            type: NodePort
            port: 313
            nodePort: 313

          grpcService:
            type: NodePort
            port: 315
            nodePort: 315

          jobImage:
            repository: 0chaindev/stake
            pullPolicy: Always
            tag: latest

          # nodeSelector: {}

          # tolerations: []

          # affinity: {}

          postgresImage:
            repository: postgres
            tag: 11

          postgresResources:
            requests:
              cpu: "50m"
              memory: "50Mi"
            limits:
              cpu: "100m"
              memory: "100Mi"

          postgresEnv:
            POSTGRES_HOST_AUTH_METHOD: trust

          postgresJobEnv:
            POSTGRES_HOST_AUTH_METHOD: trust
            POSTGRES_PORT: "5432"
            POSTGRES_USER: postgres

          postgresService:
            port: 5432

          persistence:
            enabled: false

            ## A manually managed Persistent Volume and Claim
            ## Requires persistence.enabled: true
            ## If defined, PVC must be created manually before volume will be bound
            # existingClaim:
            storageClassName: openebs-hostpath
            ## rabbitmq data Persistent Volume Storage Class
            ## If defined, storageClassName: <storageClass>
            ## If set to "-", storageClassName: "", which disables dynamic provisioning
            ## If undefined (the default) or set to null, no storageClassName spec is
            ##   set, choosing the default provisioner.  (gp2 on AWS, standard on
            ##   GKE, AWS & OpenStack)
            
            ######### PV HostPath ###########
            pvHostPath: "/mnt/kubernetes/"
            
            ####### PVs & PVCs #######
            storageClassNameFiles: blob-files-pv-
            accessModeFilesPv: ReadWriteOnce
            storageFiles: 20Gi

            storageClassNameData: blob-valid-data-pv-
            accessModeDataPv: ReadWriteOnce
            storageData: 30Gi

            storageClassNameTmp: blob-tmp-pv-
            accessModeTmpPv: ReadWriteOnce
            storageTmp: 5Gi

            storageClassNameLog: blob-valid-log-pv-
            accessModeLogPv: ReadWriteOnce
            storageLog: 3Gi

        validator:
          validatorCount: 6
          replicaCount: 1

          config:
            version: "1.0"

            # delegate wallet (must be set)
            delegateWallet: "b7ebf17502288c0ef27edc52423372aab12b595f0aeb55f3960a3bbc6c47a574"
            # min stake allowed, tokens
            minStake: "1.0"
            # max stake allowed, tokens
            maxStake: "100.0"
            # maximum allowed number of stake holders
            numDelegates: "50"
            # service charge of related blobber
            serviceCharge: "0.30"

            blockWorker: "http://helm-zdns-01"
            handlers:
              rateLimit: "10" # 10 per second

            logging:
              level: "info"
              console: "false" # printing log to console is only supported in development mode

            serverChain:
              id: "0afc093ffb509f059c55478bc1a60351cef7b4e9c008a53a6cc8241ca8617dfe"
              owner: "edb90b850f2e7e7cbd0a1fa370fdcc5cd378ffbec95363a7bc0e5a98b8ba5759"
              genesisBlock:
                id: "ed79cae70d439c11258236da1dfa6fc550f7cc569768304623e8fbd7d70efae4"
              network:
                relayTime: "100" # milliseconds
              signatureScheme: "bls0chain"
              transaction:
                minFee: 1000000000

          image:
            repository: 0chaindev/validator
            pullPolicy: Always
            tag: staging

          imagePullSecrets: 
            - name: regcred

          nameOverride: ""

          fullnameOverride: ""

          env:
            DOCKER: "true"

          # persistence:
          #   enabled: false

          #   ## A manually managed Persistent Volume and Claim
          #   ## Requires persistence.enabled: true
          #   ## If defined, PVC must be created manually before volume will be bound
          #   # existingClaim:

          #   ## rabbitmq data Persistent Volume Storage Class
          #   ## If defined, storageClassName: <storageClass>
          #   ## If set to "-", storageClassName: "", which disables dynamic provisioning
          #   ## If undefined (the default) or set to null, no storageClassName spec is
          #   ##   set, choosing the default provisioner.  (gp2 on AWS, standard on
          #   ##   GKE, AWS & OpenStack)
          #   ##
          #   # storageClass: "-"
          #   # accessMode: ReadWriteOnce
          #   # size: 20Gi

          # podAnnotations: {}

          # podSecurityContext: {}
          #   # fsGroup: 2000

          # securityContext: {}
          #   # capabilities:
          #   #   drop:
          #   #   - ALL
          #   # readOnlyRootFilesystem: true
          #   # runAsNonRoot: true
          #   # runAsUser: 1000

          service:
            type: NodePort
            port: 314
            nodePort: 314

          resources:
            requests:
              cpu: "50m"
              memory: "50Mi"
            limits:
              cpu: "100m"
              memory: "100Mi"

          # resources: {}

          # nodeSelector: {}

          # tolerations: []

          # affinity: {}
        ' > myvalues.yaml

    - name: "Deploy 0Chain network"
      shell: 'script --return --quiet --command "bash {0}"'
      run: |
        cd ..
        echo '#!/bin/bash
        echo
        echo "=================================================="
        echo "DEPLOYING 0CHAIN NETWORK"
        echo "=================================================="
        echo

        echo
        cat myvalues.yaml
        echo

        helm upgrade --install 0chain --wait --timeout 10m --set sharder.image.tag=${{ env.SHARDER_TAG }} --set miner.image.tag=${{ env.MINER_TAG }} --set sharder.config.zchain.serverChain.transaction.minFee=${{ env.MINER_FEE }} --set sharder.config.zchain.development.smartContract.fee=true -n ${{ env.NAMESPACE }} 0chain-helm/zchain --kubeconfig ./kube/${{ env.NAMESPACE }}-config
        helm upgrade --install 0dns --wait --timeout 60s --set zdns.image.tag=${{ env.ZDNS_TAG }} --set zdns.host=devnet-0chain.net -n ${{ env.NAMESPACE }}  0chain-helm/zdns --kubeconfig ./kube/${{ env.NAMESPACE }}-config
        helm upgrade --install blobber --values myvalues.yaml --wait --set blobber.config.blockWorker=https://${{ env.NAMESPACE }}.devnet-0chain.net/dns --set validator.config.blockWorker=https://${{ env.NAMESPACE }}.devnet-0chain.net/dns --set blobber.config.delegateWallet=591d6d0d5642bdbc924756ca2647b4b59adce0acd02a487ecc4d1bd4669293a8 --set validator.config.delegateWallet=591d6d0d5642bdbc924756ca2647b4b59adce0acd02a487ecc4d1bd4669293a8 --set blobber.host=devnet-0chain.net --set blobber.image.tag=${{ env.BLOBBER_TAG }} --set validator.image.tag=${{ env.VALIDATOR_TAG }} -n ${{ env.NAMESPACE }}  0chain-helm/blobber --kubeconfig ./kube/${{ env.NAMESPACE }}-config
        helm upgrade --install 0block --set zblock.host=devnet-0chain.net --set zblock.image.tag=${{ env.ZBLOCK_TAG }} -n ${{ env.NAMESPACE }}  0chain-helm/zblock --kubeconfig ./kube/${{ env.NAMESPACE }}-config
        helm upgrade --install explorer --set explorer.config.blockWorker=https://${{ env.NAMESPACE }}.devnet-0chain.net/dns --set explorer.image.tag=${{ env.EXPLORER_TAG }} --set explorer.host=devnet-0chain.net -n ${{ env.NAMESPACE }}  0chain-helm/explorer --kubeconfig ./kube/${{ env.NAMESPACE }}-config
        helm upgrade --install 0proxy --set zproxy.host=devnet-0chain.net --set zproxy.config.blockWorker=https://${{ env.NAMESPACE }}.devnet-0chain.net/dns --set zproxy.image.tag=${{ env.ZPROXY_TAG }} -n ${{ env.NAMESPACE }}  0chain-helm/zproxy --kubeconfig ./kube/${{ env.NAMESPACE }}-config
        helm upgrade --install 0box --wait --set zbox.host=devnet-0chain.net --set zbox.config.blockWorker=https://${{ env.NAMESPACE }}.devnet-0chain.net/dns --set zbox.image.tag=${{ env.ZBOX_TAG }} -n ${{ env.NAMESPACE }}  0chain-helm/zbox --kubeconfig ./kube/${{ env.NAMESPACE }}-config
        helm upgrade --install 0search --set zsearch.host=devnet-0chain.net --set zsearch.image.tag=${{ env.ZSEARCH_TAG }} -n ${{ env.NAMESPACE }}  0chain-helm/zsearch --kubeconfig ./kube/${{ env.NAMESPACE }}-config
        helm upgrade --install blobber-stake --wait -n ${{ env.NAMESPACE }} --set blobberStake.config.blockWorker=https://${{ env.NAMESPACE }}.devnet-0chain.net/dns --set blobberStake.blobberCount=6 --set blobberStake.host=devnet-0chain.net --set blobberStake.image.tag=${{ env.BLOBBER_STAKE_TAG }} 0chain-helm/blobberStake --kubeconfig ./kube/${{ env.NAMESPACE }}-config
        helm upgrade --install authorizer -n ${{ env.NAMESPACE }} --set authorizer.authorizerCount=3 --set authorizer.host=devnet-0chain.net --set authorizer.image.tag=${{ env.AUTHORIZER_TAG }} --set authorizer.config.blockWorker=https://${{ env.NAMESPACE }}.devnet-0chain.net/dns 0chain-helm/authorizer --kubeconfig ./kube/${{ env.NAMESPACE }}-config
        ' > ./deploy.sh;
        chmod 777 ./deploy.sh;
        ./deploy.sh

    - name: "Wait for 0Chain network deployment to complete"
      shell: 'script --return --quiet --command "bash {0}"'
      run: |
        cd ..
        echo '#!/bin/bash

        RETRY_ATTEMPT=$1
        ANNOTATION_LEVEL="warning"
        if [ "$1" == "final" ]; then
            ANNOTATION_LEVEL="error"
        fi

        echo "Waiting for 0Chain deployment to finish..."
        sleep 70
        counter=0;
        while [ $counter -lt 30 ] && kubectl -n ${{ env.NAMESPACE }} get pods --kubeconfig ./kube/${{ env.NAMESPACE }}-config | grep blobber-stake | grep -vi Completed; do

          if ( kubectl -n ${{ env.NAMESPACE }} get pods --kubeconfig ./kube/${{ env.NAMESPACE }}-config | grep blobber-stake | grep -i Error ); then
            echo "::$ANNOTATION_LEVEL title=0Chain network deployment failed on $RETRY_ATTEMPT attempt::blobber stake failed on $RETRY_ATTEMPT attempt"
            exit 1
          fi

          sleep 10
          echo "Still waiting for 0Chain deployment to finish..." && ((counter=counter+1));
        done

        if [ $counter -eq 30 ]; then
          echo "::$ANNOTATION_LEVEL title=0Chain network deployment failed on $RETRY_ATTEMPT attempt::Chain setup did not complete within the time limit on $RETRY_ATTEMPT attempt"
          exit 1
        fi

        echo "::notice title=0Chain network deployment was successful on $RETRY_ATTEMPT attempt::0Chain was successfully deployed to [${{ env.NETWORK_URL }}]"
        ' > ./wait.sh;
        chmod 777 ./wait.sh;
        ./wait.sh "first" || {
          echo '#!/bin/bash
          RED="\033[0;31m"
          NC="\033[0m"
          echo
          echo -e "${RED}======================================================${NC}"
          echo -e "${RED}RETRYING DEPLOYMENT ($(echo $1 | awk '"'"'{ print toupper($0) }'"'"') ATTEMPT):${NC}"
          echo -e "${RED}======================================================${NC}"
          echo
          ./teardown.sh && ./deploy.sh && ./wait.sh $1;
          ' > ./retry.sh;
          chmod 777 ./retry.sh;
          ./retry.sh "second" || ./retry.sh "final"
        }

    - name: "Create post run teardown script"
      shell: 'script --return --quiet --command "bash {0}"'
      run: |
        cd ..
        echo '#!/bin/bash

        if [ "$${{ env.TEARDOWN_CONDITION }}" == "true" ]; then
           echo
           echo "======================================================"
           echo "TEARING DOWN 0CHAIN NETWORK AFTER WORKFLOW RUN:"
           echo "======================================================"
           echo
           output=$(helm list -n ${{ env.NAMESPACE }} --kubeconfig "./kube/${{ env.NAMESPACE }}-config" | wc -l);
           if [ $output -gt 1 ]; then
              helm list --short -n ${{ env.NAMESPACE }} --kubeconfig "./kube/${{ env.NAMESPACE }}-config" | xargs -L1 helm delete -n ${{ env.NAMESPACE }} --kubeconfig "./kube/${{ env.NAMESPACE }}-config";
              sleep 30;
           fi
           kubectl delete pvc --all -n ${{ env.NAMESPACE }} --kubeconfig ./kube/${{ env.NAMESPACE }}-config;
           helm upgrade --install --wait --timeout 120s cleanup -n ${{ env.NAMESPACE }} 0chain-helm2/cleanDir --kubeconfig ./kube/${{ env.NAMESPACE }}-config;
        else
           echo "SKIPPING TEARDOWN AS CONDITION - [${{ env.TEARDOWN_CONDITION }}] WAS [$${{ env.TEARDOWN_CONDITION }}]"
        fi
        ' > ./post.sh;
        chmod 777 ./post.sh;

    - name: "POST WORKFLOW RUN: Destroy 0Chain Network"
      uses: webiny/action-post-run@2.0.1
      with:
        run: ./post.sh
        working-directory: ../
